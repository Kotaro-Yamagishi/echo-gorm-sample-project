# ディレクトリ構成
## cmd
アプリケーションのエントリーポイント

#### 注意点
- 最小限の機動処理のみに抑える（ビジネスロジックは禁止）
- 依存注入の初期化場所でもあるので、初期化隠蔽のためのbootstrap.goなどは分けてOK


## internal/app/
アプリケーションの振る舞い（usecase）を実装する主役

### handlers/
役割はWeb層（echoのルーティング最終地点）
user_handler.go: /users/:id などのエンドポイントに対応

#### 注意点
- echo.Contextが入ってくるのはこの層だけに留める（多層に依存しない）
- バリデーション・レスポンス構築まで（ビジネスロジックはサービス層で）

### services/
ビジネスロジックの本体。usecaseレイヤー

#### 格納ファイル例
user_service.go
interfaces.go や user_interface.go（必要に応じて）

#### 注意点
- interface + 実装構造をとる
- ロジックはrepositoryに依存し、handlerには依存しない
- 単体テストが可能な構成にする（mockを差し込み可能に）


### repositories
DBアクセス層層（インフラ層に相当）

#### 注意点
- Interface定義はこの層に置く（サービス層から使われる立場）
- GORMやSQLなど具体的な実装は変えられるようInterfaceで抽象化

## internal/models
ドメインモデルや構造体

#### 格納ファイル例
user.go: DBエンティティ、アプリ内で持つUserモデル
dto/ をサブディレクトリにしてリクエスト・レスポンス専用DTOを分けることも◎

#### 注意点
- DBエンティティとレスポンス構造体を分ける（密結合を避ける）
- モデルはプレーンな構造体で、ビジネスロジックを持たない（Fat Modelを避ける）

## internal/config
設定の読み込みと管理

#### 注意点
- 設定はstructにマッピング
- .envやviperなどで読み込む場合はパッケージに依存しすぎない設計が望ましい

## pkg/utils
汎用的なユーティリティコードや共通ライブラリ

#### 格納ファイル例
- hash.go: パスワードハッシュ関数
- date.go: 日付フォーマット
- jwt.go: JWT生成・検証

#### 注意点
- どの層からもimport可能になるので、依存方向に注意
- 共通処理だが、「ロジックの責務」を持たないように注意

# 設計思想的アドバイス
- 責務の分離
  - パッケージごとに「1つの役割」を持たせ、責務を混在させない。
- 依存の方向
  - handler → service → repository の一方向。逆方向依存はNG（interface + DIで実現）。
- interface重視
  - 特にservice/repositoryはinterfaceを用意し、実装と分離することでテストしやすくなる
- Echo, GORMなどの外部依存を隔離
  - 外部ライブラリに依存するコードは、必ずインフラ層（repositoryやhandler）に留める。
- 単体テストしやすい構成に	
  - モック差し替え可能に、interfaceと初期化コードを工夫する。

# Interface
## go言語におけるInterfaceの役割
- 「このパッケージ（層）がこれだけの機能を必要とする」という要求の表明.「この型がこの機能を提供する」設計ではない
- 利用者が意図を理解するため、interfaceは利用者側パッケージに置くのが原則

## 構造体ファイルとinterfaceファイルは分けるべき？
密結合を避けるため、「interface」と「struct」は分けて管理


## レイヤードアーキテクチャ

## クリーンアーキテクチャ
