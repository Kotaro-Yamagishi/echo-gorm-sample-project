## linuxカーネル
ハードウェアとユーザープログラムの橋渡し的部分
cpuやメモリ、ストレージなどのハードウェア資源を管理し、効率的かつ安全に使わせる
カーネルインターフェース経由でハードウェア資源にアクセスするので安全
ex)プロセス管理、メモリ管理、ファイルシステム管理、ネットワーク通信管理、デバイス管理

## システムコール
ユーザー空間のプログラムがカーネルの機能を使うためのapi
実際にはカーネル内にあるシステムコールインターフェース経由でカーネルにアクセスする

## スケジューリング
cpu時間の割り当てを決定する
プロセスの優先度や状態を見て、効率よくcpuを分配

## ユーザー空間
アプリケーションが実行される領域
直接ハードウェアやカーネルの重要な資源にアクセスできない空間
ユーザー空間の必要性:ユーザーが書いたプログラムがバグっても、システム全体が破壊されないようにする。
実行モードの制御で管理（ユーザーモード、カーネルモード)
仮想メモリを使って、プロセスごとにユーザー空間を管理

## メモリマネージャ
ページフレーム管理:
物理メモリをページ（通常4kb)単位で管理
仮想メモリ:各プロセスに独立した仮想メモリ空間を見せることでメモリを分離・保護
ページテーブルによって仮想アドレス<=>物理アドレスを変換
メモリ割り当て戦略:小さな領域に効率よくメモリを割り当てるためのアルゴリズム
フラグメンテーションを減らす工夫がされている
メモリ圧縮・スワップ:ramが足りない時、使ってないページをディスクに退避
kswapdというデーモンがこの制御を行う
メモリ使用量のバランス調整:oom killer


## 開発エンジニアが知っておくべきOSの知識領域
### プロセスとスレッド
フォーク、スレッドの仕組み、PID、親子関係、ライフサイクル
並列処理、非同期処理（例: Goroutine, JavaのThread）を設計する時に重要

#### プロセスとは
実行中のプログラムのインスタンスで独立している
各プロセスに個別のリソース（PID、ファイルディスクリプタ
単一または複数のスレッドを持てる
コンテキストスイッチに関しては重いので、メモリ空間の切り替えが重要

#### スレッドとは
プロセス内で実行される単位
共有（ヒープ・グローバル変数等)
リソースは同一プロセス内で共有
実際のCPU処理単位。ただし共有ゆえに同期が必要なので、データ競合に注意

#### Fork
現在のプロセスを丸ごとコピーして新しいプロセスを作るシステムコール
コピー先を子プロセス、コピー元を親プロセスと言い、PIDで判別可能

#### exec
プロセスの中身を別のプログラムに置き換える

#### forkの有用性
unixではプロセスは多くの状態を持っている
forkで親プロセスをコピーすることでこの状態を1から構築する必要なし
親子でメモリを共有
親のプロセス空間をベースにしているが、PIDやプロセス空間は完全に独立


## メモリ管理
仮想メモリ、スタックとヒープ、メモリマップ（mmap）、OOM
パフォーマンス・リーク対策・GC（Garbage Collection）を理解するため
### コード領域
プログラムの実行可能な命令がバイナリ形式で保存されるメモリ領域
cpuはこの領域に保存された命令を順次または条件的に応じて選択的に実行
### データ領域
グローバル変数と静的変数が保存される領域

### スタック領域
関数呼び出しに関連する情報が保存される領域
lifoで管理
ローカル変数や戻り先アドレス、関数引数などが保存される
関数のスコープ内だけで使う一時的なデータ
int a = 10; のような変数を格納

#### だれがスタック管理いている？
Goランタイム（Goコンパイラ+ランタイム）が自動で行なっている
Goでは各goroutineはユーザーレベルスレッド単位で独自のスタック領域を持つ
このスタックは最初は非常に小さく(2kb)、必要に応じて自動で拡張・縮小される

####　ユーザーレベルスレッドとOSスレッドの違い

| 特徴                 | ユーザーレベルスレッド（Goroutineなど） | OSスレッド（pthreadなど）  |
| ------------------ | ------------------------ | ------------------ |
| 管理者                | Goランタイム（ユーザー空間）          | OSカーネル             |
| 文脈切り替え（コンテキストスイッチ） | 速い（ユーザー空間で完結）            | 遅い（カーネル空間で実行）      |
| メモリ消費              | 少ない（数KB）                 | 多い（数百KB〜1MB）       |
| 数の上限               | 数百万でも可能                  | 数千が限界（メモリ次第）       |
| 実行単位               | OSスレッドにスケジュールされて実行       | CPU上で直接スケジューリングされる |
| ブロックの扱い            | 非同期に切り替えられる              | ブロックされるとスレッド全体が止まる |

そのため、ユーザーレベルスレッドではGoランタイムが1つのスレッド上で交互に処理しているため、OSから見ればひとつのスレッドが忙しそうにしているように見える

### Goの「GMP」モデル
| コンポーネント           | 説明                                               |
| ----------------- | ------------------------------------------------ |
| **G (Goroutine)** | ユーザーの関数や処理単位。非常に軽量。                              |
| **M (Machine)**   | OSスレッド。CPU上で直接実行される。必要に応じて増減する。                  |
| **P (Processor)** | 実行可能なGoroutineキューを持ち、MにGを渡す役割。`GOMAXPROCS`で数を設定。Pは論理CPUのため、つまりPが多くなれば並列で実行できるG（Goroutine）も多くなる |

#### 詳細な動き
アプリ起動時にGoランタイムはGOMAXPROCSの数だけPを用意
各Pが持つキューに実行待ちのGが入り、Mがそれを実行
Goroutineの数が多すぎて実行が間に合わないorブロッキングが発生→OSスレッドを追加で生成し対応
処理が落ち着けば、Mは解放

ブロッキングはシステムコール等。これが発生している間、そのOSスレッドでは他のGは実行できなくなる

#### Pを無作為に多くする弊害
基本的にはPは論理CPU数と同じ（8コアCPUはP＝8）
CPU数以上に大きくすると、スケジューラのオーバーヘッドだけが増えて非効率になることもある

### ヒープ領域
動的メモリ割り当てのための領域
osまたは言語ランタイムに必要なメモリサイズを要求
プロセス全体で共有（アプリケーションのすべての関数が参照可能）
解放やgcが必要
メモリがフラグメンテーションしやすい
関数を抜けても保持したいデータを格納する

### M:Nスケジューリングモデル
N個のユーザースレッドをM個のOSスレッドに割り当てて実行するモデル


### Escape解析
関数内で宣言された変数が、関数の外で使われる可能性があるかを解析すること。
外で使われる可能性がある → ヒープに割り当て（escape ＝ 「逃げる」）
関数内でしか使われない → スタックに割り当て（高速、GC不要）
Goコンパイラはこれをビルド時に静的解析して判断する


## システムコールとユーザーランドの違い
open(), read(), write(), mmap() など
アプリの処理がどこで重くなるか（カーネルとのやり取り）を見抜けるようになる

## ファイルシステム
inode、パーミッション、シンボリックリンク、パス解決、openat系
ファイル操作・バグ調査・セキュリティ設定で重要

## ネットワークスタック
ソケット、ポート、IP、TCP/UDP、epoll/select、パケット構造
HTTP/TCP通信、APIサーバー、負荷分散時の性能理解に直結


## シグナルと割り込み
SIGTERM, SIGKILL, SIGINT など
Dockerコンテナやシステムデーモンの停止・再起動制御に関わる

## プロセス間通信
パイプ、ソケット、共有メモリ、メッセージキュー
サービス間通信、マイクロサービス設計で活きる

## スケジューラとCPU時間の使い方
マルチタスク、優先度、スレッド切り替え
性能最適化・スレッド間競合の理解に必要

## コンテナと仮想
Dockerの内部構造や隔離性を支える技術
実運用・セキュリティ設計に必須知識

## ログと監視
syslog, journalctl, dmesg
バグ調査、システムデバッグに使う場面が多い

キャッシュ